\documentclass[a4paper,10pt]{scrartcl}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage[german]{babel}

\title{Netzwerke}
\author{}
\date{}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{Kapitel 1}
    \subsection{DNS - Domain Name System}
        Ein Domain Name System nimmt Internetadressen wie 'facebook.com' und liefert dessen IP-Adresse, 
        damit Rechner sich damit verbinden können. Wobei 'com'\footnote{Eigentlich ist der Punkt rechts von der Domain. Bei der TTL wird der Punkt meistens weggelassen. Richtig heißt es beispielsweise 'com.'} eine TLD (Top Level Domain) ist. Man unterscheidet TLDs wie folgt:
        \begin{description}
            \item [gTLD] (auch: genericTLDs, allgemeine TLD) Diese werden wieder in 2 Untergruppen aufgeteilt:
                \begin{description}
                    \item [sTLD] (auch: sponsored TLD) Diese TLD werden nur an Websiten vergeben, welche bestimmte Forderungen erfüllen. '.gov'
                    \item [uTLD] (auch: unsponsered TLD) TLD werden ohne Vorgaben vergeben. '.com, .xyz' 
                \end{description} 
            \item [ccTLD] (auch: country-codeTLD) TLD die zeigen aus welchem Land die Website kommt. '.de oder .us'
        \end{description}
        Beim Beispiel von facebook.com nennt man das .facebook eine Second-Level Domain, würde da noch www. stehen wäre das die Third-Level Doamin,
        Es können (quasi) beliebig viele Subdomains eingeführt werden. Die niedrigste Subdomain heißt hierbei Lowest-Level Domain. \\
        Eine FQDN (Fully Qualieified Domain Name) setzt sich aus TopLevelDomain, LowestLevelDomain und mindestens einer Domain dazwischen zusammem.
    \subsection{LAN - Local Area Network}
        Das LAN vernetzt Geräte auf einen bestimmten (o.a. begrenzten Bereich) Normalerweise ein Haus im privaten Gebrauch oder ein Firmen-Campus etc. Dabei sind die Geräte 
        ständig miteinander verbunden. 


\section{Kapitel 2}
    \subsection{Ethernet}
        Jede Netzwerkkarte hat eine eigene MAC-Adresse, die benutzt wird damit Rechner sich gegenseitig Nachrichten schicken können. Die Nachrichten bei Ethernet werden auch
        Frames, Package und Header genannt

        \subsubsection{Kabelspezifikationen}
            Das LAN-Kabel kann je nach Spezifikation verschiedene Eigenschaften. Eine sehr frühe Version ist das 10Base5 Kabel. Damals wurde noch ein Koaxialkabel als "physikalisches Medium"
            benutzt. Außerdem musst man ein "Dropkabel" benutzen, welches dann einerseits an den Rechner angeschlossen wird und anderesiets an einen 'Transceiver', an welchem wiederum das Koaxialkabel
            angeschlossen ist. Spezifikationen:
            \[
                \begin{tabular}{|l|c|}
                    Übertragungsrate & 10Mbit \\
                    Maximale Gesamtlänge des Netzes & 2500m \\
                    Maximale Segmentlänge & 500m \\
                    Maximale Anzahl an Knoten & 1024 \\
                    Zugriffsverfahren & CSMA / CD                
                \end{tabular}
            \]
            Ein weiterer Standard ist der 10BaseT Standard. Hier löst das Twisted Pair\footnote{Ein Kabel, welches aus mehreren Kabelpaaren besteht die miteinander verdrillt sind}
            Es gibt 4 Paare im Kabel, also 8 Pins insgesamt. An einem NIC sind Pin 1 und 2 zum senden und Pin 3 und 6 zum empfangen verantwortlich. Bei Hubs und Switches ist genau das
            umgekehrt da anonsten am Etherentplug beim Switch beide auf den selben Pins senden würden und beide auf den selben Pins zuhören (auf denen aber nichts gesendet wird).
            Möchte man jetzt zwei Rechner diretk verbinden nutzt man ein Crossover Kabel welches das Sendepaar und Empfängerpaar an einem Ende des Kabels vertauscht. 
        \subsubsection{5-4-3(-2-1)-Regel}
            Wie schon erwähnt können Rechner direkt mit einem Crossover Kabel miteinander kommunizieren. Wenn das Netzt aber mehr als 2 Teilnehmer haben soll werden die Patch Kabel mit 
            ihren Transceiver benötigt. Dabei hat sich die 5-4-3 oder auch die Repeater-Regel entwickelt. Sie gilt wenn sich Netzsegmente (10 Mbit) zu einer Baumtopologie verbinden. \\
            Der Pfad zwischen 2 Rechnern verläuft durch maximal
            \[
                \begin{tabular}{ll}
                    5 & Segemte mit \\
                    4 & Repeatern verlaufen darf. Es dürfen nur an \\
                    3 & Segmente aktive Endgeräte angeschlossen sein. \\
                    2 & Segmente sind dabei Linksegmente (nur Repeater). Dies bildet \\
                    1 & Kollisionsdomaine 
                \end{tabular}
            \]   

        \subsubsection{Ethernet Brücke}
            Ein Hub ist eine Netzkomponente welceh Rechner miteinander verbindet und erstellt dadurch eine Kollisionsdomaine. Die verfügbare Bandbreite wird dann von den Rechnern geteilt.
            Eine transparent Bridge entkoppelt Kollisionsdomaine (erstellt aus einer großen, mehrere kleine Kollisionsdomaine) wodruch dann eine Broadcastdomaine entsteht. Will ein Rechner 
            ein Paket an einen anderen Rechner senden, muss die Bridge das Paket anschauen um dann zu schauen ob das Paket in eine andere Kollisionsdomaine weitergeleitet werden muss, oder 
            ob das Paket in der jetzigen Kollisionsdomaine bleibt. Arbeitweise von einer Bridge:
            
            \begin{description}
                \item[1.] Bridge empfängt ein Paket
                \item[2.] Die Source-Mac wird dann in die Porttabelle eingetragen.
                \item[3.] Ist die Destination-Mac in der Porttablle bekannt wird das Paket dementsprechen weitergeleitet (forwarding) bzw. wenn die Source-Mac und die Destination-Mac in der
                selben Kollisionsdomaine sind, wird gefiltert (Paket bleibt in der Kollisionsdomaine)
                \item[4.] Wenn nicht, wird ein Broadcast an alle Ports (außer dem Source Port) gesendet und auf eine Antwort gewartet (flooding)
                \item[5.] Sobald die Antwort eingetroffen ist, wird die Mac des Rechners in die Porttabelle eingetragen.
                \item[6.] = Schritt 3 
            \end{description}

            Kenngrößen von Bridges:
            \begin{description}
                \item[Filter Rate] Wie viele Frames können pro Zeiteinheit gefiltert werde. Höher als bei Forwarding, da frames nur geprüft und ggf. verworfen werden
                \item[Forwarding Rate] Anzahl der Frames, die pro Zeiteinheit weitergeleitet werden können. Ist Höchstanzahl erreicht, arbeitet diw Bridge in "full wired speed"
                \item[Anzahl der Adresstabelleneinträge:] Wie viele MAC-Adressen in Porttabelle gespeichert werden können
            \end{description}

        \subsection{Aloha}
            Aloha ist ein Zugriffsverfahren für Ethernet. Aloha ist der Vorgänger von CSMA / CD. Zugriffsverfahren werden bei Etherent benötigt, damit mehrere Rechner nicht gleichzeitig
            auf einem Kanal senden, da sie sonst ihre Nachrichten gegenseitig verfälschen. 
            Aloha schaut zuerst ob der Kanal frei ist und sendet eben nur dann, wenn der Kanal frei ist. 
            Dabei hört der Rechner die ganze Zeit den Kanal ab und vergleicht die Daten im Kanal mit seinen eigenen. Sind diese nicht identisch gibt es eine Störung auf dem Kanal. 
            Es wird angenommen das ein anderer Rechner sendet, der ebenfalls merkt dass seine Daten verfälscht wurden. 
            Beide Rechner sendet jetzt ein sogenanntes JAM-Signal (32-bit langes, zufälliges Datenmuster). Nach dem Senden muss noch herausgefunden werden, wer jetzt senden darf, damit es nicht wieder 
            zu einer Kollision kommt. Das Verfahren wird 'truncated binary exponential backoff' genannt. Als erstes wird eine Zufallszahl 'i' ermittelt 
            \footnote{wobei i $\leq$ $2^k$ und 'k' die Anzahl der registrierten Kollisionen ist, und k $\leq$ 10 ist}
            'i' wird jetzt mit der Slottime 'T' (Die Zeit die ein Paket braucht um 2\footnote{'Hin- und Rückweg'} mal das ganze Segment zu durchlaufen). Die Formel lautet dann 
            \[ W = i \cdot T \] 

        \subsubsection{CSMA / CD (Carrier Sense Multiple Access / Collision Detection)}
            A, B und C sind Rechner im selben Netzwerk
            A und C senden zum selben Zeitpunkt, das sie merken der Kanal ist frei
            Es kommt zur Kollision die erkannt wird. Da beide Rechner den Kanal abhören merken sie,
            dass das Signal verfälschtist, brechen ab Pakete zu senden und senden JAM  und nutzen 'truncated binary exponential backoff' (Rechung wie bei Aloha) um
            nicht wieder direkt eine Kollision zu verursachen. \\
            Eine logische '0' darf nicht als 0V gesendet werden, da ein Rechner anonsten denken könnte das der Kanal frei ist obwohl gerade gesendet wird. Zur Codierung wird
            der Manchester Code beutzt. \\
            Daten werden in Ethernet zu einem Datenpaket zusammengefasst, auch 'data frame' genannt. Dieser besitzt u.a. eine Prüfsumme und Mindestlänge.
            Die Mindestlänge ist wichtig, da sich das Paket über das Kabel komplett ausbreiten muss. Am ende des Kabels ist ein Widerstand, der das Paket vernichtet
            Kommt kein signal zurück, ist die Übertragung gelungen, kommt ein Signal zurück muss ein anderer Rechner gesendet haben. Es kommt zur Kollision.
            Sobald aber A mit senden fertig ist, warten die anderen Rechner eine gewisse Zeit, bevor sie mit dem senden anfangen (interframe gap), um sicherzustellen, dass
            A auch wirklich fertig ist. 
        \subsubsection{Ethernet II}
            \[
                \begin{tabular}{|c|c|c|c|c|c|c|}
                    \hline
                        Preamble & SFD & Dest. MAC & Source MAC & Type & Data & FCS \\
                    \hline
                \end{tabular}
            \]

            \begin{description}
                \item[Preamble] 7 $\times$ 01010101, wird zu Taktsynchronisation benutzt. Wird von der NIC gelöscht (7 Byte)
                \item[SFD] 1 $\times$ 01010101, zeigt dass die Preamble fertig ist. Wird von der NIC gelöscht (1 Byte)
                \item[Destination Mac] Die MAC Adresse an den der Frame gerichtet ist (6 Byte) 
                \item[Source MAC] Die MAC Adresse vom Sender (6 Byte)
                \item[Type] Gibt wie die Daten in 'Data' zu interpretieren ist. Ist oft an die nächst höhere Schicht wichtig. 
                Außerdem gilt wenn 'Type' $\leq$ 0x600, handelt es sich um ein IEEE802.3 Frame (2 Byte)
                \item[Data] Inhalt des Frame (min 46 Byte aber höchstens 1500)
                \item[FCS] Frame Checks Sum, beim Senden wird die FCS berechnet und gesetzt. Beim Empfangen wird diese wieder berechnet und verglichen. Sind die Werte nicht identisch, wird der Frame verworfen (4 Byte) 
            \end{description}
        
        \subsubsection{IEEE 802.3}
            \[
                \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
                    \hline
                        Preamble & SFD & Dest. MAC & Source MAC & Length & Data & PAD & FCS \\
                    \hline
                \end{tabular}
            \]
            \begin{description}
                \item[Preamble] 7 $\times$ 01010101, wird zu Taktsynchronisation benutzt. Wird von der NIC gelöscht (7 Byte)
                \item[SFD] 1 $\times$ 01010101, zeigt dass die Preamble fertig ist. Wird von der NIC gelöscht (1 Byte)
                \item[Destination Mac] Die MAC Adresse an den der Frame gerichtet ist (6 Byte) 
                \item[Source MAC] Die MAC Adresse vom Sender (6 Byte)
                \item[Length] Länge der Bits Die 'Data' benötigt
                \item[Data] Inhalt des Frame (0 - 1500 Byte)
                \item[PAD] Abgesehen von Preamble und SFD muss ein Frame 64 Byte groß sein. Bei IEE wird deshalb das Feld 'PAD' mit Füllbytes belegt so dass 'Data' + 'Pad' $\geq$ 46.
                Dabei schaut 'PAD' auf das 'Length' Feld (0 - 46 Byte)
                \item[FCS] Frame Checks Sum, beim Senden wird die FCS berechnet und gesetzt. Beim Empfangen wird diese wieder berechnet und verglichen. Sind die Werte nicht identisch, wird der Frame verworfen (4 Byte) 
            \end{description}
            Da IEEE 802.3 kein Type-Feld explizit angegeben hat, wird dies in 
        \subsubsection{Spanning Tree}
            Um Schleifen beim Weiterleiten von Paketen zu vermeiden wurde das Spanning Tree Protocol (STP) eingeführt. Dafür geht man von einer Root-Bridge, von der aus dann andere Bridges
            durch eine Baumtopologie angesprochen werden können. Außerdem werden noch Pfade nach bestimmten Kriterien berechnet, die dann auch eindeutig bestimmt sind. Merkt die Route-bridge, dass eine
            andere Bridge eine Schleife erzeugt, wird diese in Stand-By gesendet. Die Bridge erhält weiterhin Pakete, leitet diese aber nicht weiter. Außerdem erhält sie dauernd von der Root-Bridge sogenannte 
            (BPDU) Pakete. Wenn diese nicht ankommen wird von einem Fehler im Netz ausgegangen und die komplette Baumstruktur wird neu erstellt.
            \subsubsection*{BPDU}
            Der Aufbau einer BPDU (Bridge Protocol Data Unit) ist wie folgt: 
            \begin{description}
                \item[Protocol Identifier] Wert = 0 da SPT (2 Byte)
                \item[Protocol Version Identifier] Wert = 0 da SPT (1 Byte)
                \item[BPDU] (Bridge Protocol Data Unit) Type: 0 : Configuration (1 Byte)
                \item[Flags] z.B. wird hier angezeigt, ob sich die Topologie geändert hat (1 Byte)
                \item[Root ID] Bridge Identifier der Root-Bridge (8 Byte)
                \item[Root Path Cost] Summe der Kosten des Pfades von der Root-Bridge an gemessen (4 Byte)
                \item[Bridge Identifier] Identifier der Bridge, die diesen Datenrahmen ausgesendet hat (8 Byte)
                \item[Port Identifier] Kennzeichnung des Ports über das dieser Datenrahmen gesendet wurde (2 Byte)
                \item[Message Age] Geschätzte Zeit in 1/256 Sekunde ab dem Absenden der BPDU durch die Root Bridge (2 Byte)
                \item[Max Age] Zeiteinheit in 1/256 Sekunde nach der Protokoll- Informationen, die über ein Port empfangen wurden, von der Bridge gelöscht werden sollen (2 Byte)
                \item[Hello Time] Zeitdauer zwischen dem Absenden von 2 aufeinander folgenden Hello- Nachrichten (besondere BPDUs) durch die Root- Bridge (2 Byte)
                \item[Forward Delay] Zeitdauer, die ein Bridgeport in den Zuständen listening und learning verweilt, bevor dieser Port in den Zustand forwarding übergeht (2 Byte)
            \end{description}
            
            Für das Flag-Byte gelten folgenden Werte:
            \[
                \begin{tabular}{c|c}
                    bits & usage \\
                    \hline
                    1 & 0 or 1 for Topology Change \\
                    2 & 0 (unused) or 1 for Proposal \\
                    3-4 & 00 (unused) or \\
                    & 01 for Port Role Alternate/Backup  \\
                    & 10 for Port Role Root  \\
                    & 11 for Port Role Designated  \\
                    5 & 0 (unused) or 1 for Learning  \\
                    6 & 0 (unused) or 1 for Forwarding  \\
                    7 & 0 (unused) or 1 for Agreement  \\
                    8 & 0 or 1 for Topology Change Acknowledgement
                \end{tabular}
            \]
            \subsubsection*{Aufbau des Baums}
            Zuerst wird die Root Bridge  ermittelt. Danach wird mit Hilfe des Root Path Cost (RPC) feld (in der BPDU) emittlett, welcher Pfad zur Root-Brige der Günstigste ist.
            Die Kosten werden durch die Geschwindigkeit (Bandbreite) ermittelt, desto höher die Geschwindkeit desto niedriger die Kosten.
            Die Root-Bridge hat 0 Im Kosten Feld. Es werden BPDUs abwärts geschickt (Bridge empfängt am Root Port die BPDU) und jede Bridge addiert 
            ihre RPC zu dem in der BPDU stehenden RPC. Bei einer Schleife empfangen 2 verschieden Bridges gegenseitig ihre RPC. Einer der beide Bridges wird in 
            StandBy geschickt (wenn RPC unterschiedlich, dann die mit der niedrigeren RPC, bei gleicher RPC, die mit niedrigerem Bridge Identifier).

            \subsubsection*{Zustände}
            Werden Bridges während dem Betrieb ausgewächselt oder entfernt (topologie change), könnte es zu Schleifen kommen wenn Bridge direkt vom blocking Zustand
            in den forwarding Zustand gewchselt wird. Deshalb gibt es Zwischenzustände die eben zwischen blocking und forwarding liegen: 
                
            \begin{description}
                \item[1.] Nach dem Einschalten in den Zustand blocking
                \item[2.] Aus dem Zustand blocking in einen der Zustände disabled oder listening
                \item[3.] Aus dem Zustand listening in einen der Zustände disabled oder learning
                \item[4.] Aus dem Zustand learning in einen der Zustände disabled oder forwarding
                \item[5.] Aus dem Zustand forwarding in den Zustand disabled
            \end{description} 
            Bei korrekter Konfiguration ist am Ende die Bridge entweder im blocking oder forwarding Zustand.

            \begin{description}
                \item[Zustand listening]
                Protokollinformation werden ausgewertet (kann sein dass port hier in StandBy gesetzt wird wenn eine Schleife erkannt wurde).
                Port wartet auf ablaufen des Forward Delay Timer und wechselt in listening Zustand. Es werden keine Frames weitergeleitet.
                Der Forward delay timer wird zurückggesetzt.
                \item[Zustand learning]
                Es werden immernoch keine Frames weitergeleitet aber die Bridge merkt sich Dource MAC von Paketen und am welchem Port der Frame empfangen wurde.
                Beim Ablauf vom Forward Delay Timer wird in Zustand forwarding gewechselt.
            \end{description}

        \subsubsection{Switching}
            Ein Switch funktioniert wie eine Bridge, nur hat eine Bridge idR. nur 2 Ports, was heutzutage nicht mehr aussreicht. 
            Pufferung:
            Bei einem Switch können mehrere Rechner miteinander kommunizieren, da ein Switch Pakete zwischenspeichern (puffer) kann. Ist das Zielsegmetn belegt 
            speichert der Switch das Paket in den Pufferspeicher. Hier gibt es 2 Arten:
            \begin{description}
                \item[port-base memory] jeder Port hat eigenen Speicher 
                \item[shared memory buffering] alle Ports haben einen gemeinsamen Speicher
            \end{description}         
            Bei 'shared memory buffering' ist der Vorteil dass jeder Port sich einfach so viel Speicher belegt wie benötigt wird. Dies ist besonder nützlich wenn ein Switch mit
            verschieden Geschwindigkeiten arbeitet (100Mbit und Gigabit), da wenn ein Gerät nur 100 Mbit braucht nicht 900 Mbit verschwendet werden. Hier muss der Switch aber 'asymmetric switching'
            unterstüzen, da anonsten nur eine Geschwindigkeit für alle Ports benutzt werden kann (wird dann 'symmetric switching' genannt).\\
            Desweiteren kann ein Switch auf verschiedene Arten arbeiten::
            \begin{description}
                \item[Store and Forward] Die Checksum wird vom Paket überprüft. Ist diese falsch wird das Paket verworfen, ansonsten wird dieser weitergeleitet (wie bei der Bridge)
                \item[cut-trough] Hier gibt es noch 2 Abspaltungen:
                    \begin{description}
                        \item[fast-forwarding] Mac wird sofort weitergeleitet sobald diese "gefunden" wurde, keine Checksum Überprüfung was die Latenz verbessert aber die Fehlerqoute der Pakete erhöht. 
                        \item[fragment-free-switching] Wenn 64 Byte ohne Kollision empfagen werden, wird  das Paket erst weitergeleitet, da ab 64 Byte keine reguläre Kollsion entstehen kann.
                    \end{description}  
            \end{description} 
            Manchmal werden auch beide Methoden verwendet, wenn z.B. cut trough zu viele fehlerhafte Frames sendet wird auf store and forward geswitcht (wird intelligent switching genannt).
            
        \subsubsection{VLAN}
            Switches lassen sich per Software in logische switches aufteilen. Ein logischer Switch  entspricht dann einem VLAN.
            Rechner könne an verschiedenen physikalischen switches angeschlossen sein aber sich im selben logischen VLAN befinden.
            Nur Rechner im selben VLAN können direkt kommunizieren. Broad/Multicast gelten dann auch nur im VLAN. \\
            Damit Switches die verschiedenen VLAN berücksichtigen können, wird der IEEE802.1Q Datenrahmen benutzt, welcher 'tagging' unterstützt. Der 4 Byte lange 'tag' befindet
            sich dann zwischen dem 'source mac' und dem 'type' Feld. Rechner mit selben Tag können untereinander kommunizieren, ansonsten muss ein Router verwendet werden wenn Rechenr aus 
            2 verschiedenen VLANs kommunizieren möchten. \\
            Da Spanning Tree die Mac Adressen vom Switch (Bridge) benutzt um die Topologie aufzubauen, wird die Bridge-ID modifiziert. Die Priority ist anstatt 2 Byte nur noch 4 Bit 
            (halbes Byte) groß. Die restlichen 12 Bits ist die VLAN-ID. Ein Switch hat für alle VLANs die er in seiner Datenbank hat eine nicht eindeutige MAC-Adresse die dann eben den 
            MAC-adress Anteil in der Bridge-ID ersetzt. Für jedes VLAN wird dann das STP ausgeführt.
       \newpage
\section{Kapitel 3}
    \subsection{IPv4}
    Jedes Gerät hat eine IPv4 Adresse, jeweils 4 Byte, dargestellt durch Dezimalzahlen durch Punkte getrennt. Beispiel 141.69.1.23. 
    \subsubsection{Adressklassen}
    \begin{description}
        \item[Klasse A:] Erstes Bit ist 0, die nächsten 7 Bit dienen der Netzwerkadressierung und die restlichen 24 Bit zur Geräteadressierung. (erstes Byte 0-127). Maske 255.0.0.0
        \item[Klasse B:] Erste beiden Bits sind 10, die nächsten 14 Bit sind zur Netzwekadressierung und die restlichen 16 Bit zur Geräteadressierung. (erstes Byte 128-191). Maske 255.255.0.0
        \item[Klasse C:] Beginnt mit 110, dann 21 Bit zur Netzwerkadressierung und 8 Bit zur Geräteadressierung. (erstes Byte 192-223). Maske 255.255.255.0
        \item[Klasse D:] Beginnt mit 1110 und dient dem Multicasting. Die restlichen 26 Bit dienen der Gruppenadresse
        \item[Klasse E:] Beginnt mit 1111, ausschließlich für Forschungszwecke reserviert.
    \end{description}
    \subsubsection{APIPA-Adressen}
        Falls ein Computer keine IP von einem DHCP-Server zugewiesen bekommt, vergibt er sich selbst eine IP von 169.254.0.0-169.254.255.255. Diese Adressen werden nie von einem Router weitergeleitet.
    \subsubsection{Eigene Subnetze}
        Mit einer Netzwekmaske kann die Host-ID zusätzlich in Subnetze unterteilt werden. So kann eine skalierbarere Netzwerkstruktur geschaffen werden.
    \subsection{IP-Routing}
        Die Routing-Tabelle eines Routers oder Computers enthält folgende Einträge:
        \begin{description}
        \item[Netzwerkziel:] Das Netzwerk, das über das das entsprechende Interface erreicht werden kann.
        \item[Netzwerkmaske:] Zum Feststellen der Net-ID des Netzwerks
        \item[Gateway:] Wohin soll geschickt werden, wenn kein direct Routing zum Ziel möglich ist?
        \item[Schnittstelle:] Über welche Ausgang-Schnittstelle soll das Paket versendet werden?
        \item[Metrik:] Bei mehreren zur Verfügung stehenden Pfaden wird der Weg mit der geringsten Metrik verwendet.
        \end{description}
        Wenn kein passender Eintrag in der Routing-Tabelle gefunden wird, wird automatisch die \textbf{Default Route} verwendet. Meistens 0.0.0.0 als Netzwerkziel und Netzwerkmaske\\ \\
        \textbf{Net-Specific Routes:} Routingeinträge zu Netzen und Subnetzen. Wird automatisch für alle Netze eingetragen, in denen sich der Router selbst befindet.\\ \\
        \textbf{Host-Specific Routes:} Routingeinträge zu einzelnen Hostrechnern, z.B. DNS-Rootservern
    \subsection{ARP - Address Resolution Protocol}
        ARP wird verwendet, wenn ein Computer oder Router ein Paket an ein Gerät im eigenen Netz senden will, aber nur die Ziel-IP-Adresse kennt. 
        Er schickt dann ein Ethernet II Frame mit dem Typ-Feld 0x608 an die Broadcast-Adresse FF-FF-FF-FF-FF-FF. Wenn der gesuchte Rechner das Paket empfängt, 
        antwortet er mit seiner MAC-Adresse. 
        \[
        \begin{tabular}{|p{2.5cm}|p{2.5cm}|p{2.5cm}|p{2.5cm}|}
            \toprule 
            1 & 2 & 3 & 4  \\
            \midrule\midrule
            \multicolumn{2}{|c|}{Hardware Type} & \multicolumn{2}{|c|}{Protocol Type} \\
            \midrule
            HLEN & PLEN & \multicolumn{2}{|c|}{Operation} \\
            \midrule
            \multicolumn{4}{|c|}{Sender Hardware Address Byte 0-3} \\
            \midrule
            \multicolumn{2}{|c|}{Sender Hardware Address Byte 4-5} & \multicolumn{2}{|c|}{Sender Internet Address Byte 0-1} \\
            \midrule
            \multicolumn{2}{|c|}{Sender Internet Address Byte 2-3} & \multicolumn{2}{|c|}{Target Hardware Address Byte 0-1}\\
            \midrule
            \multicolumn{4}{|c|}{Target Hardware Address Byte 2-5}\\
            \midrule
            \multicolumn{4}{|c|}{Target Internet Adress Byte 0-3}\\
            \bottomrule
        \end{tabular}
        \]
        Die einzelnen Felder bedeuten dabei:
        \begin{description}
            \item[Hardware Type] beschreibt, über welches Mittel kommuniziert wird. Ethernet bedeutet dabei 1.
            \item[Protocol Type] Mit welchem Protokoll soll später kommuniziert werden? Das gleiche wie bei Ethernet II, also 0x800 für IP.
            \item[HLEN] beschreibt, wie lange eine Hardware-Adresse ist. Ist bei Ethernet immer 6.
            \item[PLEN] beschreibt, wie lange eine Protokoll-Adresse ist. Ist bei IPv4 immer 4.
            \item[Operation] Was wird gerade ausgeführt? 1 für Request, 2 für Response
            \item[Sender Hardware Address] ist die MAC-Adresse des Senders
            \item[Sender Internet Address] ist die IP-Adresse des Senders
            \item[Target Hardware Address] ist die MAC-Adresse des Empfängers
            \item[Target Internet Address] ist die IP-Adresse des Enpfängers.
        \end{description}
        Die gesuchten Felder werden mit Nullen gefüllt. Mit “reverse ARP” kann ein Computer, der über das Netzwerk gebootet wurde, die IP-Adresse zu seiner eigenen MAC-Adresse erfragen. Dazu ist allerdings ein Server nötig.
    \subsection{ICMP - Internet Control Message Protocol}
        ICMP-Pakete sind in IP-Pakete eingepackt (Protocol-Feld wird auf 1 gesetzt). Es wird unter anderem verwendet, um  die Erreichbarkeit von Systemen im Internet zu testen (ping), Netzwerkfehler zu erkennen und um bei Zeitüberschreitungen benachrichtigt zu werden.
        \[
            \begin{tabular}{|p{2.5cm}|p{2.5cm}|p{2.5cm}|p{2.5cm}|}    
                \toprule 
                1 & 2 & 3 & 4  \\
                \midrule\midrule
                Type & Code & \multicolumn{2}{|c|}{Checksum}\\
                \bottomrule
            \end{tabular}
        \]
        Die gültigen Werte für das Type-Feld sind:
        \begin{description}
            \item[0:] Echo Reply (bei ping)
            \item[3:] Destination unreachable (der Sender wird benachrichtigt, wenn das Ziel nicht erreichbar ist). Die Gründe dafür können im Code-Feld stehen
            \begin{description}
            \item[0:] net unreachable
            \item[1:] host unreachable
            \item[2:] protocol unreachable
            \item[3:] port unreachable
            \item[4:] Fragmentation needed and DF set
            \item[5:] source route failed (der Sender hat eine Route im IP-Header angegeben, die nicht funktioniert hat)
            \end{description}
            \item[4:] Source Quench (der Empfänger bittet den Sender, weniger Pakete zu senden)
            \item[5:] Redirect (Wird von Routern verwendet, um die Netzwerkroute zu beeinflussen)
            \item[8:] Echo (bei ping)
            \item[11:] Time exceeded (TTL wurde unterschritten)
            \item[12:] Parameter Problem, ungültiger IP Header
            \item[13:] Timestamp (für Zeit-Synchronisierung)
            \item[14:] Timestamp Reply (für Zeit-Synchronisierung)
        \end{description}
        Durch das Code-Feld können zusätzliche Informationen mitgegeben werden, z.B. warum die Verbindung gescheitert ist.
    \subsection{TCP}
        TCP stellt eine virtuelle Verbindung zwischen den Kommunikationspartnern her. Durch die Verbindung können Daten zuverlässig übermittelt werden. Bei TCP und UDP gibt es Ports, an die die Daten gesendet werden. \emph{Well known Ports} gehen von 0 bis 1023 sind u. a.:\\
        \[
        \begin{tabular}{|c|c|}
            \hline
            Dienst & Portnummer \\
            \hline
            http & 80 \\
            https & 443 \\
            SMTP (E-Mail versenden) & 25\\
            POP3 (E-Mail abholen) & 110\\
            FTP & 20, 21 \\
            ssh & 22 \\
            \hline
        \end{tabular}  \\
        \]
        Damit der Server antworten kann, sendet der Client auch eine Portnummer als \emph{source port} mit, an die die Antwort geschickt werden soll. Weil sich diese Ports immer ändern können, heißen sie auch dynamische Ports. Sie gehen von Port 49152 bis 65535. Zwischen den Well known ports und den dynamic ports liegen die registered Ports von 1024 bis 49151.\\ \\
        Eine TCP-Verbindung entsteht über einen \textbf{3way Handshake}.
        \begin{description}
        \item[1. (SYN)] Der Client sendet ein Paket, bei dem das SYN-Feld gesetzt ist und mit welcher Sequence Number er beginnen möchte.
        \item[2. (ACK+SYN)] Der Server antwortet dem Client mit einem Paket, bei dem die SYN + ACK Felder gesetzt sind. Außerdem teilt er dem Client die eigene Sequence Number mit.
        \item[3. (ACK)] Der Client bestätigt die Antwort und beide bauen eine sichere Verbindung zur Kommunikation auf.
        \end{description}
        Nun kann kommuniziert werden. Der Client sendet die Daten und zählt dabei die gesendeten Bytes mit der Sequence Number hoch. Die Sequence Number ist immer ein Pointer auf das erste Byte im aktuellen Paket. Er kann nur so viele Daten wie die Window size senden, ohne auf ein acknowledgen des Servers zu warten. Der Server acknowledged ein einzelnes oder mehrere Pakete mit einem ACK-Paket. Acknowledgement Number ist dabei die als nächstes erwartete Sequence-Number des Gegenübers.\\
        Die TCP-Verbindung wird über einen \textbf{4way Handshake} geschlossen.
        \begin{description}
        \item[1. (FIN)] Der Client will die Verbindung trennen und sendet ein FIN-Paket.
        \item[2. (ACK)] Der Server bestätigt den Erhalt des FIN-Pakets.
        \item[3. (FIN)] Sobald das Programm auf dem Server bereit ist, die Verbindung zu schließen, wird ein FIN-Paket an den Client gesendet.
        \item[4. (ACK)] Der Client bestätigt den Erhalt des Pakets. Die Verbindung wird beendet.
        \end{description}
        \[
        \begin{tabular}{|p{2.8cm}|p{2.8cm}|p{2.8cm}|p{2.8cm}|}
            \toprule 
            1 & 2 & 3 & 4  \\
            \midrule\midrule
            \multicolumn{2}{|c|}{Source Port} & \multicolumn{2}{|c|}{Destination Port}\\
            \midrule
            \multicolumn{4}{|c|}{Sequence Number}\\
            \midrule
            \multicolumn{4}{|c|}{Acknowledgement Number}\\
            \midrule
            \begin{tabular}{p{10mm}|p{1cm}}
             data offset &  reserved \\
            \end{tabular} & flags &  \multicolumn{2}{|c|}{window}\\
            \midrule
            \multicolumn{2}{|c|}{checksum} & \multicolumn{2}{|c|}{urgent pointer}\\
            \midrule
            \multicolumn{4}{|c|}{options}\\
            \multicolumn{4}{|c|}{0 oder mehr 32bit Wörter}\\
            \midrule
            \multicolumn{4}{|c|}{Daten...}\\
            \bottomrule
        \end{tabular}
        \]
    Die Felder bedeuten dabei folgendes:
    \begin{description}
    \item[Source Port] Port, von dem aus das Paket geschickt wird.
    \item[Destination Port] Port, an den das Paket gesendet wird.
    \item[Sequence Number] Alle übertragenen Bytes sind durchnummeriert, beginnend bei einem zufälligen Wert.
    \item[Acknowledgement Number] Nur gültig, wenn die ACK-Flag gesetzt ist. Quittiert alle Pakete vom Gegenüber mit einer Acknowledgement Number = Sequence Number+1.
    \item[Data Offset] gibt die Zahl der 32bit-Wörter im TCP-Header an. Min 5, wenn keine Options verwendet werden.
    \item[reserved] Bits werden nicht verwendet.
    \item[Flags] Es gibt folgende Flags:
    \begin{description}
        \item[0: CWR] Für uns irrelevant
        \item[1: ECE] Für uns irrelevant
        \item[2: URG] Das Urgent Pointer Feld enthält gültige Daten
        \item[3: ACK] Die Acknowledgement Nummer ist gültig
        \item[4: PSH] Die Daten des TCP Nutzlasten-Feldes sofort an die nächsthöhere Schicht liefern. (z.B. Telnet)
        \item[5: RST] Reset: Die Verbindung soll vom Rechner, der RST sendet, zurückgesetzt werden.
        \item[6: SYN] Wird beim Verbindungsaufbau verwendet.
        \item[7: FIN] Wird beim Schließen der Verbindung verwendet.
    \end{description}
    \item[window] Teilt dem Kommunikationspartner mit, wie viele Datenbytes er noch senden darf, bevor er auf eine Quittierung warten muss.
    \item[checksum] Prüfsumme auf Fehler im Header
    \item[urgent pointer] Pointer auf das letzte Byte, was zu den Vorrangsdaten (urgent data) gehört.
    \item[options] Optionale Daten % Vllt noch genauer erklären
    \end{description}
    \subsection{UDP}
        UDP bietet einen Datagramm-Dienst für die darüberliegende Schicht an. UDP ist unzuverlässig und verbindungslos. Wird oft verwendet, wenn die Ziel-Adresse Broadcast oder Multicast ist. Der UDP-Header sieht wie folgt aus:\\
        \[
        \begin{tabular}{|p{3cm}|p{3cm}|p{3cm}|p{3cm}|}
            \toprule 
            1 & 2 & 3 & 4  \\
            \midrule\midrule
            \multicolumn{2}{|c|}{Source Port} & \multicolumn{2}{|c|}{Destination Port}\\
            \midrule
            \multicolumn{2}{|c|}{Length} & \multicolumn{2}{|c|}{Checksum}\\
            \midrule
            \multicolumn{4}{|c|}{Daten...}\\
            \bottomrule
        \end{tabular}\\ \\
        \]
        Das \textbf{Length}-Feld bezieht sich dabei auf die Länge von UDP-Header + Daten. \\
        UDP wird u. a. verwendet für:\\ 
        \begin{tabular}{|c|c|}
            \hline
            Dienst & Portnummer \\
            \hline
            Trivial File Transfer Protocol (TFTP) & 69 \\
            Domain Name Services (DNS) & 53 \\
            Simple Network Management Protocol (SNMP) & 161/162\\
            Routing Information Protocol (RIP) & 520\\
            \hline
        \end{tabular}  \\ 


        \section{Kapitel 4}
            \subsection{Router}
                Ein Router empfängt Pakete der Schicht 3 (IP-Frame) und schaut in seiner Routing Tablle nach ob wohin das Paket geschickt werden muss. Kollisionsdomaine und Broadcastdomaine
                enden bei einem Router. Es können aber Ausnahmen konfiguriert werden, die dann einen Broadcast weiterleiten, was beispielsweise für DHCP wichtig ist. \\
                Cisco Router sind Rechner mit spezieller Software: 
                \begin{description}
                    \item[RAM/DRAM] speichert Routing-Tabellen, enthält ARP-Speicher, schnelles Switching und Paketzwischenspeicher (gemeinsam genutztes RAM) sowie Warteschlangenspeicher zum Halten
                    von Paketen. Verliert Daten bei unterbrochener Stromversorgung
                    \item[NVRAM] speichert BackUp/Startkonigzrationsdateien von Router, Daten überleben Stromunterbrechung
                    \item[FLASH] programmierbarer ROM welche idR das Betriebssytem enthält, dadurch muss nicht gelötet werden für ein Softwarupdate, bzw mehrere Versionen von können IOS gespeichert werden
                    \item[ROM] enthält Einschaltdiagnosefunktionen, ein Bootstrap-Programm und Betriebssystemsoftware
                    \item[Software] IOS (Internetwork Operating System) Betriebssystem von Cisco Routern, Router kann über Telnet konfiguriert (Routen setzen etc.) werden bzw. 
                        Informationen weitergeben die beispielsweise für Fehlersuche wichtig sein könnten
                \end{description}

            \subsection{RIP - Routing Information Protocol}
                RIP dient zur dynamischen Erstellung von Routing Tabellen.
                \subsubsection{Distanzvektoralgorithmus}
                    RIP benutzt den Distanzvektoralgorithmus um die 'schnellste' Route von einem Router zum anderen anzugeben. Die 'Geschwindigkeit' wird hierbei mit den hop counts angegeben,
                    weniger Router hops $\Leftrightarrow$ höhere 'Geschwindigkeit'. Router die direkt verbunden sind haben die metric 0, Router können ihre Routen an andere Router weiterleiten und
                    der Empfänger Router erhöht dann einfach die metric\footnote{hop count $\Leftrightarrow$ metric} für jede Route um eins.
                    Bekommt ein Router eine bessere Route als eingespeichert, so ersetzt er diese mit der besserern, bekommt ein Router eine Route die gleich gut ist, wird die neue gesepeichert, wobei die alte Route bestehen bleibt. 
                \subsubsection{Arbeitsweise}
                    \begin{description}
                        \item Alle 30 Sekunden (Update Timer) senden Router ihre Routen weiter als flooded broadcast (IP = 255.255.255.255, MAC = FF:FF:FF:FF:FF:FF) und bekommt den UDP port $520_{dec}$ (sowohl Source als auch Destination)
                        Dabei hat jeder Router seinen eigenen Timer $\Rightarrow$ asynchron. Wenn ein Router die Routeninforamtion erhält verändert er wenn nötig seine eigene Routingtabelle
                    \end{description}
                    Desweiteren haben Routen auch selbst einen eigenen Timer. Läuft dieser ab wird die Route dann an andere Router gesendet, bzw. Router erwarten, dass Routen gesendet werden.
                    Empfängt ein Router 180 Sekunden lang kein Update der Route, wird diese als unerreichbar markiert (metrix wird auf 16 gesetzt). Ausßerdem wird wieder ein Routing update gesendet 
                    (außerhalb des 30 Sekunden Zeitfenster), Das sogennante 'triggered update'. Dies wird allgemein ausgelöst, wenn sich in einer Route die 
                    metric ändert und es werden hier auch nur die geänderten Routen an die Router gesendet.\\
                    Wird nach weiteren 120 (Bei Cisco 240) Sekunden (Flush Timer) immernoch nicht die Route empfangen wird diese dann gelöscht (garbage collection). \\
                    Da jetzt noch die anderen Router von der falschen Route erst noch erfahren müssen, gibt es noch Holddown Tiemr (180 Sekunden). Er erhält die falsche Route in dieser Zeit
                    damit Schleifen nicht auftauchen können.
                
                \subsection{Aufbau einer RIP Nachricht}
                    \[
                    \begin{tabular}{|p{2.5cm}|p{2.5cm}|p{2.5cm}|p{2.5cm}|}
                        \toprule 
                        1 & 2 & 3 & 4  \\
                        \midrule
                        command & version & \multicolumn{2}{|c|}{must be zero} \\
                        \bottomrule
                    \end{tabular}
                    \]

                    \begin{description}
                        \item[command] $\!$
                            \begin{itemize}
                                \item[1.] RIP-Request: Router wird auffgefordert sofort einen RIP response zu senden.
                                    Enthält die Routen vom Sender und fordert auf die Routen an die Nachbarrouter zu senden.
                                \item[2.] RIP-Response: RIP Routenankündigun. Entweder zyklisch alle 30 Sekunden oder als triggered update.
                            \end{itemize}
                        \item[version] Hier wird die RIP-Version angegeben. Dieses Feld enthält bei RIP 1 immer den Wert 1. 
                        \item[must be zero] Die Bits werden nicht verwendet. Sie sind auf 0 gesetzt.
                    \end{description} 

                \subsubsection*{Routenangabe}
                    \[
                    \begin{tabular}{|p{2.5cm}|p{2.5cm}|p{2.5cm}|p{2.5cm}|}
                        \toprule 
                        1 & 2 & 3 & 4  \\
                        \midrule
                        \multicolumn{2}{|c|}{Adress Family Identifier} & \multicolumn{2}{|c|}{must be zero} \\
                        \midrule
                        \multicolumn{4}{|c|}{IP Adresss} \\
                        \midrule
                        \multicolumn{4}{|c|}{must be zero}\\
                        \midrule
                        \multicolumn{4}{|c|}{must be zero}\\
                        \midrule
                        \multicolumn{4}{|c|}{Metric} \\
                        \bottomrule
                    \end{tabular}
                    \]

                    \begin{description}
                        \item[Adress Family Identifier] 
                            Dieses Feld  gibt darüber Aufschluss, für welches Schicht 3–Protokoll die Routing-Informationen in der RIP-Nachricht gelten.
                            Bei IP-Routing-Informationen wird dieses Feld auf den Wert 2 gesetzt. 
                        \item[IP Adress]  In diesem Feld wird die IPv4-Adresse des Netzwerkziels angegeben. Dabei
                            kann es sich um eine Route zu einem Netz, einem Subnetz oder zu einem
                            einzelnen Rechner (host-specific route) handeln. Findet sich hier der
                            Eintrag 0.0.0.0, so handelt es sich um die Ankündigung der default route.
                        \item[Metric] In dieses Feld wird der hop count zum Netzwerkziel eingetragen. Der hop
                            count gibt an, wie viele Router besucht werden müssen, um das betreffende
                            Netzwerkziel zu erreichen. Der maximal erlaubte hop count liegt bei einer
                            gültigen Route beim Wert 15. Der Wert 16 bedeutet, dass ein Netzwerkziel
                            nicht erreichbar ist.
                    \end{description}
                \subsubsection*{Probleme bei Routenausfall}
                    
                    Ein Router A sendet an Router B die Route zum Router C. Jetzt fällt Router C aus aber Router B denkt er hat die Route zu C und sagt Router A bescheid. 
                    Router A trägt jetzt eine Route zu C über B in sich ein. Router B merkt aber jetzt dass keine updates von der Route kommen und löscht diese Route. Router A
                    sagt jetzt aber, dass er eine Route zu C hat und Router B trägt das auch in seine Routingtabelle ein. Das wiederholt sich bis die metric auf 16 gesetzt ist. Da dies
                    aber einige Minuten dauern kann wurden vorgehensweisen etwickelt, um eben dies zu beschleunigen\footnote{Muss noch korrigiert werden.}:
                    \begin{description}
                        \item[Split-Horizon] 
                            Wenn Router A Routen vom Router B lernt, sendet er diese Routen nicht mehr zurück (an Router B).
                            Hat Router A aber auch Routen von einem Router C sendet A die Routen von C an den Router B 
                        \item[Split-Horizon with poison revers] Wie split Horizion nur dass antatt Routen die eigentlich nicht gesendet werden, die metric einfach auch 16 gesetzt wird. 
                            (Router A sendet die Routen von Router B an den ROuten B zurück mit metric = 16)
                        \item[triggered-update] 
                            Bei Topologie Änderung (metric ändert sich) wird sofort ein RIP-Update an die Nachbarn gesendet
                    \end{description}
            
\end{document}
